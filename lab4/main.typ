#import "conf.typ": conf
#import "@preview/zebraw:0.5.5": zebraw, zebraw-init, zebraw-themes
#show: conf.with(
  title: [Лабораторная работа №4],
  type: "pract",
  info: (
    author: (
      name: [Тюменцева Радомира Александровича],
      faculty: [КНиИТ],
      group: "251",
      sex: "male",
    ),
    inspector: (
      degree: "Старший преподаватель",
      name: "Е. М. Черноусова",
    ),
  ),
  settings: (
    title_page: (
      enabled: true,
    ),
    contents_page: (
      enabled: false,
    ),
  ),
)

= Задание 4

*Вариант 1.* Массив из 20 чисел заполнить последовательностью, состоящей наполовину из чётных чисел (2, 4, ...) и наполовину из квадратов этих чисел; организовать вывод массива на экран в виде таблицы 2x10 с фиксированной шириной столбцов:

#figure(
  image("./image4.2.gif", width: 60%),
  caption: [
    Вывод в виде таблицы 2x10 массива из 20 чисел.
  ],
)<img1>

== Краткий словестный алгоритм программы

+ Вывод фамилии, имени и номера группы.
+ Заполнение в цикле первых 10 элементов массива `simple` чётными числами: от 2 до 20.
+ Вычисление квадратов этих чисел и заполнение вторых 10 элементов массива `simple` квадратами чётных чисел: от 4 до 400.
+ Перевод первых 10 элементов массива `simple` в символы ASCII и вывод первой строки чётных чисел.
+ Перевод первых 10 элементов массива `simple` в символы ASCII и вывод второй строки квадратов чётных чисел.
+ Завершение работы программы.

== Текст программы на языке ассемблера с комментариями

```asm
.model small
.stack 100h
.186

.data
	my_name db "Tyumentsev Radomir, 251$"
	simple dw 20 dup (?) ; Массив из 20 слов (неинициализированный)
	result db 5 dup (' '), '$' ; Буфер для вывода одного числа: 5 символов + '$'
	nl     db 0AH, 0Dh, '$' ; Символы перехода на новую строку

.code
start:
	mov AX, @data
	mov DS, AX

	;   Вывод фамилии, имени и номера группы
	lea DX, my_name
	mov AH, 09h
	int 21h

	lea DX, nl
	mov AH, 09h
	int 21h

	mov CX, 10; Количество чисел
	mov BX, 2; Первое число
	mov SI, 0; Смещение в байтах (0)

fill_even_loop:
	mov  simple[SI], BX
	add  SI, 2
	add  BX, 2
	loop fill_even_loop

	;   Заполнение второй половины массива квадратами
	mov CX, 10
	mov BX, 2
	mov SI, 20; Смещение к 11-му элементу (10 слов * 2 байта)

fill_sq_loop:
	mov  AX, BX
	mul  BX; AX = BX*BX
	mov  simple[SI], AX
	add  SI, 2
	add  BX, 2
	loop fill_sq_loop

	;   Вывод первой строки (чётные числа)
	mov CX, 10
	mov SI, 0; Начинаем с первого элемента

print_first_row:
	mov  AX, simple[SI]
	mov  BX, 10
	call word_asc
	mov  AH, 9
	lea  DX, result
	int  21h
	add  SI, 2
	loop print_first_row

	;   Перенос строки
	mov AH, 9
	lea DX, nl
	int 21h

	;   Вывод второй строки (квадраты)
	mov CX, 10
	mov SI, 20; Начинаем с 11-го элемента

print_second_row:
	mov  AX, simple[SI]
	mov  BX, 10
	call word_asc
	mov  AH, 9
	lea  DX, result
	int  21h
	add  SI, 2
	loop print_second_row

	;   Перевод строки
	mov AH, 9
	lea DX, nl
	int 21h

	;   Завершение программы
	mov AX, 4C00h
	int 21h

  word_asc proc
    pusha
    mov SI, 0; Смещение в байтах, изначально 0, затем увеличивается до 5
    mov CX, 5; Длина строки result (5 символов)

  ; Заполняем буфер пробелами для очистки
  fill_spaces:
    mov  result[SI], ' '
    inc  SI
    loop fill_spaces

  convert_loop:
    dec SI
    mov DX, 0
    div BX; AL = частное, AH = остаток
    add DL, '0'
    mov result[SI], DL
    cmp AX, 0
    jne convert_loop

    popa
    ret
  word_asc endp

end start
```
#text(size: 12pt, align(center)[Текст программы])
#pagebreak(weak: true)

== Скриншоты запуска программ
#align(center)[#image("1.png")]
#text(size: 12pt, align(center)[Запуск программы])

= Ответы на контрольные вопросы

*1. Какой командой можно выделить в памяти место под одномерный массив байтов array размерностью 20?*

#h(1cm)Для выделения памяти существуют директивы db, dw, dd, dq, dt, выделяющие, в зависимости от конкретной директивы, байт, слово, двойное слово, и так далее. К ним применим оператор dup, позволяющий выделить несколько экземпляров:

```asm array db 20 dup (?) ```

При использовании `(?)` ячейки выделенной памяти не будут инициализироваться конкретными значениями.

В результате выполнения приведённой в примере директивы будет выделено 20 байт памяти с начальным адресом под меткой `array`.

Перечислив значения через запятую, можно проинициализировать конкретные байты, слова, и так далее, соответственно.

*2. Опишите команды умножения на байт и на слово.*

Для умножения значения регистра AL или AX на число используется инструкция `mul` для беззнаковых чисел или `imul` для знаковых: 

```asm 
mul <второй множитель>
mul BL; AX = AL * BL
mul BX; DX:AX = AX * BX
```

Команда умножения может устанавливать только флаги переноса и переполнения.

Команда `mul` устанавливает оба флага, если старшая половина результата не нулевая. Если умножаются два байта, установка флагов переполнения и переноса показывает, что результат умножения больше 255 и не может содержаться в одном байте. В случае умножения слов флаги устанавливаются, если результат больше 65535.

*3. Какое максимальное беззнаковое число можно хранить в элементе массива размером в 1 байт?*

Число 255 = $2^8 - 1$.

*4. Пусть имеется массив: array DW 50 DUP(?). Для доступа к отдельным элементам массива используется адресное выражение array[SI]. Как называется этот способ адресации и как с его помощью будет вычисляться адрес элементов массива?*

Прямая адресация с индексированием. `array` определяет адрес начала массива, а значение в SI - индекс элемента, прибавляющийся к адресу (смещение).

*5. Каким образом осуществляется перебор элементов некоторого массива A с помощью адресного выражения A[SI], если массив состоит из байтов, слов или двойных слов?*

Задаётся CX, равный количеству элементов массива, а затем в цикле постепенно увеличивается SI на размер элемента массива (байт, слово или двойное слово, соответственно), и происходит постепенное смещение по элементам. 

```asm
mov CX, 5; Если в массиве 5 элементов
mov SI, 0
array_loop:
    mov AX, A[SI]
    add SI, 2; Для слова
    loop array_loop
```

*6. Для некоторого массива array, объявленного следующим образом: array DW 20 DUP(?), каким будет результат выполнения команды mov DI, array и команды mov DI, offset array?*

В первом случае в DI будет помещено значение первого элемента массива `array`, а во втором - адрес начала массива `array`.
