#import "conf.typ": conf
#import "@preview/zebraw:0.5.5": zebraw, zebraw-init, zebraw-themes
#show: conf.with(
  title: [Лабораторная работа №4],
  type: "pract",
  info: (
    author: (
      name: [Тюменцева Радомира Александровича],
      faculty: [КНиИТ],
      group: "251",
      sex: "male",
    ),
    inspector: (
      degree: "Старший преподаватель",
      name: "Е. М. Черноусова",
    ),
  ),
  settings: (
    title_page: (
      enabled: true,
    ),
    contents_page: (
      enabled: false,
    ),
  ),
)

= Задание 4

*Вариант 1.* Массив из 20 чисел заполнить последовательностью, состоящей наполовину из чётных чисел (2, 4, ...) и наполовину из квадратов этих чисел; организовать вывод массива на экран в виде таблицы 2x10 с фиксированной шириной столбцов:

#figure(
  image("./image4.2.gif", width: 60%),
  caption: [
    Вывод в виде таблицы 2x10 массива из 20 чисел.
  ],
)<img1>

== Краткий словестный алгоритм программы

+ Вывод фамилии, имени и номера группы.
+ Заполнение массива `simple` через вложенный цикл:
  + В первой итерации цикла `fill_rows` в цикле `fill_cols` заполняются первые 10 элементов чётными числами.
  + Во второй итерации цикла `fill_rows` в цикле `fill_cols` заполняются следующие 10 элементов их квадратами.
+ Вывод массива `simple` в две строки через вложенный цикл с переводом чисел в строки ASCII фиксированной длины.
+ Завершение работы программы.

== Текст программы на языке ассемблера с комментариями

```asm
.model small
.stack 100h
.186

.data
	my_name db "Tyumentsev Radomir, 251$"
	simple dw 20 dup (?) ; Массив из 20 слов (неинициализированный)
	result db 5 dup (' '), '$' ; Буфер для вывода одного числа: 5 символов + '$'
	nl     db 0AH, 0Dh, '$' ; Символы перехода на новую строку

.code
start:
	mov AX, @data
	mov DS, AX

	;   Вывод фамилии, имени и номера группы
	lea DX, my_name
	mov AH, 09h
	int 21h

	call print_new_line

	mov CX, 2; Количество строк
	mov SI, 0; Смещение в байтах (0)

  ; Заполнение массива
  ; Первые 10 элементов - чётные числа, следующие 10 - их квадраты
  fill_rows:
    mov BX, 2; Первое число

    fill_cols:
      mov AX, BX
      cmp CX, 2
      je even
      mul AX; AX = AX * AX (возведение в квадрат)
      even:
      mov simple[SI], AX; Занесение числа в массив
      add SI, 2
      add BX, 2
      cmp SI, 20
      je fill_rows_loop
      cmp SI, 40
      je fill_rows_loop
      jl fill_cols
      fill_rows_loop:
        loop fill_rows

	mov CX, 2; Количество строк
	mov SI, 0; Смещение в байтах (0)

  ; Вывод массива в две строки
  print_rows:
    print_cols:
      mov AX, simple[SI]; Занесение числа из массива в AX
      call word_asc; Перевод числа в строку ASCII
      lea DX, result
      call print_string; Вывод строки
      add SI, 2
      cmp SI, 20
      je print_rows_loop
      cmp SI, 40
      je print_rows_end
      jl print_cols
      print_rows_loop:
        call print_new_line
        loop print_rows
      print_rows_end: 

	; завершение программы
	mov AX, 4C00h
	int 21h

  ; Процедура перевода числа в строку ASCII фиксированной длины
  word_asc proc
    pusha
    mov BX, 10; Основание системы счисления
    mov SI, 0; Смещение в байтах, изначально 0, затем увеличивается до 5
    mov CX, 5; Длина строки result (5 символов)

    ; Заполнение буфера result пробелами для его очистки
    fill_spaces:
      mov  result[SI], ' '
      inc  SI
      loop fill_spaces

    ; SI = 5
    ; Заполнение буфера result символами
    convert_loop:
      dec SI
      mov DX, 0; Обнуление прошлого остатка от деления
      div BX; AX = частное, DX = остаток
      add DL, '0' ; Добавление кода символа 0 в ASCII
      mov result[SI], DL; Занесение символа в буфер
      cmp AX, 0
      jne convert_loop

    popa
    ret
  word_asc endp

  ; Процедура вывода строки, хранящейся в DX
  print_string proc
    push AX

    mov AH, 09h
    int 21h

    pop AX
    ret
  print_string endp

  ; Процедура переноса строки
  print_new_line proc
    push AX
    push DX

    lea DX, nl
    mov AH, 09h
    int 21h

    pop DX
    pop AX
    ret
  print_new_line endp

end start
```
#text(size: 12pt, align(center)[Текст программы])
#pagebreak(weak: true)

== Скриншоты запуска программ
#align(center)[#image("1.png")]
#text(size: 12pt, align(center)[Запуск программы])

= Ответы на контрольные вопросы

*1. Какой командой можно выделить в памяти место под одномерный массив байтов array размерностью 20?*

#h(1cm)Для выделения памяти существуют директивы db, dw, dd, dq, dt, выделяющие, в зависимости от конкретной директивы, байт, слово, двойное слово, и так далее. К ним применим оператор dup, позволяющий выделить несколько экземпляров:

```asm array db 20 dup (?) ```

При использовании `(?)` ячейки выделенной памяти не будут инициализироваться конкретными значениями.

В результате выполнения приведённой в примере директивы будет выделено 20 байт памяти с начальным адресом под меткой `array`.

Перечислив значения через запятую, можно проинициализировать конкретные байты, слова, и так далее, соответственно.

*2. Опишите команды умножения на байт и на слово.*

Для умножения значения регистра AL или AX на число используется инструкция `mul` для беззнаковых чисел или `imul` для знаковых: 

```asm 
mul <второй множитель>
mul BL; AX = AL * BL
mul BX; DX:AX = AX * BX
```

Команда умножения может устанавливать только флаги переноса и переполнения.

Команда `mul` устанавливает оба флага, если старшая половина результата не нулевая. Если умножаются два байта, установка флагов переполнения и переноса показывает, что результат умножения больше 255 и не может содержаться в одном байте. В случае умножения слов флаги устанавливаются, если результат больше 65535.

*3. Какое максимальное беззнаковое число можно хранить в элементе массива размером в 1 байт?*

Число 255 = $2^8 - 1$.

*4. Пусть имеется массив: array DW 50 DUP(?). Для доступа к отдельным элементам массива используется адресное выражение array[SI]. Как называется этот способ адресации и как с его помощью будет вычисляться адрес элементов массива?*

Прямая адресация с индексированием. `array` определяет адрес начала массива, а значение в SI - индекс элемента, прибавляющийся к адресу (смещение).

*5. Каким образом осуществляется перебор элементов некоторого массива A с помощью адресного выражения A[SI], если массив состоит из байтов, слов или двойных слов?*

Задаётся CX, равный количеству элементов массива, а затем в цикле постепенно увеличивается SI на размер элемента массива (байт, слово или двойное слово, соответственно), и происходит постепенное смещение по элементам. 

```asm
mov CX, 5; Если в массиве 5 элементов
mov SI, 0
array_loop:
    mov AX, A[SI]
    add SI, 2; Для слова
    loop array_loop
```

*6. Для некоторого массива array, объявленного следующим образом: array DW 20 DUP(?), каким будет результат выполнения команды mov DI, array и команды mov DI, offset array?*

В первом случае в DI будет помещено значение первого элемента массива `array`, а во втором - адрес начала массива `array`.
