#import "conf.typ": conf
#import "@preview/zebraw:0.5.5": zebraw, zebraw-init, zebraw-themes
#show: conf.with(
  title: [Лабораторная работа №2],
  type: "pract",
  info: (
    author: (
      name: [Тюменцева Радомира Александровича],
      faculty: [КНиИТ],
      group: "251",
      sex: "male",
    ),
    inspector: (
      degree: "Старший преподаватель",
      name: "Е. М. Черноусова",
    ),
  ),
  settings: (
    title_page: (
      enabled: true,
    ),
    contents_page: (
      enabled: false,
    ),
  ),
)

= Задание 3

Сначала программы должны печатать фамилию, имя и номер группы студента и переходить на новую строку. Используя рассмотренное упражнение, выполните следующие задания:

== Задание 3.1

В регистре AX задано число от 0 до 65535. Выведите это число на экран. (Проверить программу для числа более 2600.)

== Задание 3.2

Используя 32-битные регистры процессора (EAX, EBX, EDX), напишите программу, выводящую на экран число 65536. Число 65536 изначально поместить в регистр EAX.

== Тексты программ на языке ассемблера с комментариями

```asm
.model small
.stack 100h

.data
my_name db 'Tyumentsev Radomir, 251', 0Dh, 0Ah, '$'

.386 ; Разрешение трансляции команд процессора 386
.code

start:
	mov AX, @data; Помещение указателя на сегмент данных в AX
	mov DS, AX; Помещение указателя на сегмент данных в DS

	;   Вывод фамилии, имени и номера группы
	mov DX, offset my_name
	mov AH, 09h
	int 21h

	mov AX, 3456; Занесение числа
	mov BX, 10; Занесение основания системы счисления (делителя)
	mov CX, 0; Обнуление счётчика

  loop_first: ; Занесение в стек цифр числа
    inc  CX; Увеличение счётчика
    mov  DX, 0; Обнуление остатка от деления в DX
    div  BX; Деление AX на BX
    push DX; Занесение остатка от деления в стек
    cmp  AX, 0; Сравнение частного с нулём
    jne  loop_first; Если AX != 0, то возвращаемся к loop_first

  mov AH, 02h ; Занесение в AH кода команды вывода символа

  loop_second: ; Вывод цифр числа из стека
    pop  DX
    call out_digit
    loop loop_second

  ; Завершение программы
  mov AX, 4C00h
  int 21h

  ; Процедура вывода цифры
  out_digit proc
    add DX, 30h; Перевод цифры в ASCII
    int 21h
    ret
  out_digit endp

end start
```
#text(size: 12pt, align(center)[Текст программы 1])
#pagebreak(weak: true)

```asm
.model small
.stack 100h

.data
my_name db 'Tyumentsev Radomir, 251', 0Dh, 0Ah, '$'

.386 ; Разрешение трансляции команд процессора 386
.code

start:
	mov AX, @data; Помещение указателя на сегмент данных в AX
	mov DS, AX; Помещение указателя на сегмент данных в DS

	;   Вывод фамилии, имени и номера группы
	mov DX, offset my_name
	mov AH, 09h
	int 21h

	mov EAX, 65536; Занесение числа
	mov EBX, 10; Занесение основания системы счисления (делителя)
	mov CX, 0; Обнуление счётчика

  loop_first: ; Занесение в стек цифр числа
    inc  CX; Увеличение счётчика
    mov  EDX, 0; Обнуление остатка от деления в DX
    div  EBX; Деление EAX на EBX
    push EDX; Занесение остатка от деления в стек
    cmp  EAX, 0; Сравнение частного с нулём
    jne  loop_first; Если EAX != 0, то возвращаемся к loop_first

  mov AH, 02h ; Занесение в AH кода команды вывода символа

  loop_second: ; Вывод цифр числа из стека
    pop  EDX
    call out_digit
    loop loop_second

  ; Завершение программы
  mov AX, 4C00h
  int 21h

  ; Процедура вывода цифры
  out_digit proc
    add EDX, 30h; Перевод цифры в ASCII
    int 21h
    ret
  out_digit endp

end start
```
#text(size: 12pt, align(center)[Текст программы 2])

== Скриншоты запуска программ
#align(center)[#image("1.png")]
#text(size: 12pt, align(center)[Запуск программы 1])
#align(center)[#image("2.png")]
#text(size: 12pt, align(center)[Запуск программы 2])

= Ответы на контрольные вопросы

*1. Чем отличается деление на байт от деления на слово? (где должно располагаться делимое, куда попадут частное от деления и остаток от деления)*

Деление на байт:
- Делимое должно располагаться в регистре AX (для 16-битных операций) или AL (для 8-битных операций).
- Частное от деления помещается в AL, а остаток — в AH.

Деление на слово:
- Делимое должно располагаться в регистре DX:AX (для 32-битных операций) или в AX (для 16-битных операций).
- Частное помещается в AX, а остаток — в DX.

*2. Каков механизм действия команды cmp? В паре с какими командами она обычно используется?*

Команда CMP выполняет сравнение двух операндов путем вычитания одного из другого. Результаты вычитания не сохраняются, но устанавливаются соответствующие флаги в регистре EFLAGS:
- ZF устанавливается, если операнды равны.
- CF устанавливается, если первый операнд меньше второго (для беззнаковых чисел).
- SF устанавливается, если результат отрицательный (для знаковых чисел).
- OF устанавливается при переполнении знакового результата.

Часто команда CMP используется перед командами условного перехода (JE, JNE, JG, JL и т.д.), которые принимают решения на основе установленных флагов.

*3. На какие флаги реагируют команды условного перехода для чисел со знаком и для чисел без знака?*

Для чисел со знаком:
- JG (Jump if Greater): SF = OF и ZF = 0
- JL (Jump if Less): SF ≠ OF
- JE или JZ (Jump if Equal): ZF = 1

Для чисел без знака:
- JA (Jump if Above): CF = 0 и ZF = 0
- JB (Jump if Below): CF = 1
- JE или JZ: ZF = 1

*4. С помощью команд условного и безусловного перехода выполните программную реализацию алгоритма ветвления для определения наименьшего числа из двух заданных. Алгоритм изображен в виде блок-схемы, приведенной на Рис.@img1.*

#figure(
  image("./image3.3.png", width: 30%),
  caption: [
    Организация ветвления на машинном уровне:\
    R1 - первое число хранится в регистре AX;\
    R2 - второе число хранится в регистре BX;\
    R3 - результат заносится в регистр DX;\
    vr2, cont - метки команд.
  ],
)<img1>

```asm
.model small
.stack 100h

.code
start:
  ; Задание значений R1 и R2
  mov AX, 5; R1
  mov BX, 3; R2

  cmp AX, BX; Сравнение R1 с R2
  jl vr2; Если R1 < R2, переход к метке vr2

  ; Если R1 >= R2
  mov DX, BX; Сохранение R2 как результат
  jmp cont; Переход к завершению

  vr2:
    mov DX, AX; Сохранение R1 как результат

  cont: ; Завершение программы
    mov AX, 4C00h
    int 21h

end start
```

*5. Каков механизм работы команды организации цикла LOOP?*

Команда LOOP уменьшает значение регистра CX на единицу и выполняет переход по указанной метке, если CX не равен нулю. Это позволяет организовать циклы с фиксированным количеством итераций. Пример:

```asm
mov CX, 5; Установка количество итераций
loop_start:
    ; Ваш код здесь
    loop loop_start; Переход к loop_start, пока CX не станет равным нулю.
```

*6. Как с помощью команды сдвига можно умножить знаковое число, хранящееся в АХ, на 2 в n-ой степени?*

Чтобы умножить число в регистре AX на $2^n$, можно использовать команду сдвига влево (SHL). Например:
```asm
mov AX, 3; Пример для числа 3
shl AX, 1; Умножаем на 2 (3 * 2 = 6)
shl AX, 2; Умножаем на 4 (6 * 4 = 24)
```
Каждый сдвиг влево увеличивает степень двойки.

*7. Как с помощью команды сдвига проверить содержимое регистра ВХ на четность?*

Чтобы проверить четность числа в регистре BX, можно использовать команду сдвига вправо (SHR) и проверять младший бит:
```asm
mov BX, some_value; Значение для проверки четности
shr BX, 1; Сдвигаем вправо на один бит
jnc is_even; Если нет переноса, число четное

is_odd:
; Код для обработки нечетного числа

is_even:
; Код для обработки четного числа
```
Если после сдвига младший бит равен нулю (нет переноса), то число четное.
