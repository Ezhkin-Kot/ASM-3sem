#import "conf.typ": conf
#import "@preview/zebraw:0.5.5": zebraw, zebraw-init, zebraw-themes
#show: conf.with(
  title: [Лабораторная работа №2],
  type: "pract",
  info: (
    author: (
      name: [Тюменцева Радомира Александровича],
      faculty: [КНиИТ],
      group: "251",
      sex: "male",
    ),
    inspector: (
      degree: "Старший преподаватель",
      name: "Е. М. Черноусова",
    ),
  ),
  settings: (
    title_page: (
      enabled: true,
    ),
    contents_page: (
      enabled: false,
    ),
  ),
)

= Задание 2

Сначала программы должны печатать фамилию, имя и номер группы студента и переходить на новую строку. Затем аналогично рассмотренному упражнению выполните следующие задания:

== Задание 2.1

Первая цифра задана в AX, вторая цифра задана в BX. Написать программу, которая выводит в одну строку первую цифру, пробел, вторую цифру.

== Задание 2.2

Первая цифра задана в AX, вторая цифра задана в BX. Написать программу, которая выводит в одну строку первую цифру (AX), пробел, вторую цифру (BX). Далее совершает обмен значений регистров AX и BX и снова в новой строке на экране выводит в одну строку первую цифру (AX), пробел, вторую цифру (BX). Обмен совершить без использования дополнительной памяти, регистров. *Структура программы должна обязательно содержать одну или более вспомогательных процедур.*

== Тексты программ на языке ассемблера с комментариями

#[
#set text(size: 12pt)
#zebraw(
  numbering: true,
  lang: false,
  ```asm
  .model tiny               
  .code                     
  org 100h  

  start:
    ; Вывод фамилии, имени и номера группы
    mov DX, offset my_name
    call out_string
    call new_line
    
    mov AX, 1    ; Занесение первой цифры в регистр AX
    mov BX, 2    ; Занесение второй цифры в регистр BX
    ; Перевод цифр в коды соответствующих символов ASCII с помощью команды add
    add AX, 30h  
    add BX, 30h    

    ; Вывод первой цифры
    mov DX, AX
    call out_char

    ; Вывод пробела 
    call out_space

    ; Вывод второй цифры 
    mov DX, BX
    call out_char

    ; Завершение программы
    mov AX, 4C00h
    int 21h

    ; Процедура вывода строки
    out_string proc
      mov AH, 09h
      int 21h
      ret
    out_string endp

    ; Процедура вывода символа
    out_char proc
      mov AH, 02h
      int 21h
      ret
    out_char endp

    ; Процедура вывода пробела
    out_space proc
      mov DL, 00h ; Код пробела в ASCII
      mov AH, 02h
      int 21h
      ret
    out_space endp

    ; Процедура перехода на новую строку
    new_line proc
      mov DX, offset end_line
      mov AH, 09h
      int 21h
      ret
    new_line endp

  ;===== Data =====
  my_name db 'Tyumentsev Radomir, 251$'
  end_line db 0Dh, 0Ah, '$' ; Строка с символами перехода на новую строку
  end start
  ```
)
]
#text(size: 12pt, align(center)[Текст программы 1])
#pagebreak(weak: true)

#[
#set text(size: 12pt)
#zebraw(
  numbering: true,
  lang: false,
  ```asm
  .model tiny
  .code
  org    100h

  start:
    ;    Вывод фамилии, имени и номера группы
    mov  DX, offset my_name
    call out_string
    call new_line

    mov AX, 1; Занесение первой цифры в регистр AX
    mov BX, 2; Занесение второй цифры в регистр BX
    ;   Перевод цифр в коды соответствующих символов ASCII с помощью команды add
    add AX, 30h
    add BX, 30h

    ;    Сохранение значения регистра AX в стек
    ;    так как затем в него будут записываться номера функций DOS
    push AX

    ;    Вывод первой цифры
    mov  DX, AX
    call out_char

    ;    Вывод пробела
    call out_space

    ;    Вывод второй цифры
    mov  DX, BX
    call out_char

    pop AX; Восстановление значения регистра AX из стека

    xchg AX, BX; Обмен значениями регистров AX и BX

    call new_line; Переход на новую строку

    ;    Вывод первой цифры
    mov  DX, AX
    call out_char

    ;    Вывод пробела
    call out_space

    ;    Вывод второй цифры
    mov  DX, BX
    call out_char

    ;   Завершение программы
    mov AX, 4C00h
    int 21h

    ;   Процедура вывода строки
    out_string proc
      mov AH, 09h
      int 21h
      ret
    out_string endp

    ;   Процедура вывода символа
    out_char proc
      mov AH, 02h
      int 21h
      ret
    out_char endp

    ;   Процедура вывода пробела
    out_space proc
      mov DL, 00h; Код пробела в ASCII
      mov AH, 02h
      int 21h
      ret
    out_space endp

    ;   Процедура перехода на новую строку
    new_line proc
      mov DX, offset end_line
      mov AH, 09h
      int 21h
      ret
    new_line endp

  ;===== Data =====
  my_name db 'Tyumentsev Radomir, 251$'
  end_line db 0Dh, 0Ah, '$' ; Строка с символами перехода на новую строку
  end start
  ```
)
]
#text(size: 12pt, align(center)[Текст программы 2])

== Скриншоты запуска программ
#align(center)[#image("1.png")]
#text(size: 12pt, align(center)[Запуск программы 1])
#align(center)[#image("2.png")]
#text(size: 12pt, align(center)[Запуск программы 2])

== Таблицы трассировки программ
#let tracetable(caption, filename) = {
  set text(lang: "ru")
  figure(
    caption: caption,
    {
      let trace = csv(filename)

      set text(size: 8pt)

      table(
        columns: 13,
        table.header(
          table.cell(rowspan: 2, [Шаг]), table.cell(rowspan: 2, [Машинный код]),
          table.cell(rowspan: 2, [Команда]),
          table.cell(colspan: 9, [Регистры]),
          [Флаги],
          [AX], [BX], [CX], [DX], [SP], [DS], [SS], [CS], [IP], [CZSOPAID],
        ),
        ..trace
          .map(r => {
            r
          })
          .flatten(),
      )
    },
  )
}
#tracetable("Таблица трассировки программы 1", "table1.csv")
#tracetable("Таблица трассировки программы 2", "table2.csv")

= Ответы на контрольные вопросы

*1. В какой регистр надо поместить код выводимого символа? Какой код Dos-функции используется для вывода отдельного символа на экран?*

В регистр DL заносится номер используемой для операции вывода функции.
Для вывода символа на экран используется функция DOS 02h, которая заносится в регистр AH.
Затем используется прерывание при помощи команды `int 21h`

```asm
mov DL, 00h ; Символ пробела
mov AH, 02h
int 21h
```

*2. Какая операция позволяет получить для цифры её код в кодовой таблице?*

Для вывода на экран цифры необходимо сначала преобразовать её в символьную форму. То есть, для получения символьной формы необходимо заменить цифру кодом ASCII её изображения. Для этого к цифре, хранящейся в регистре, необходимо прибавить командой ADD число 30h – шестнадцатеричный код цифры 0 в ASCII.

```asm
add AX, 30h
```

*3. Объясните назначение процедуры. Как определяются начало и конец процедуры?*

Практически все современные программы состоят из одной главной программы и небольших частей, то есть подпрограмм (или *процедур*). (Главная программа вызывает эти процедуры на выполнение, передавая им управление процессором. После завершения работы процедуры возвращают управление главной программе и выполнение продолжается с команды, следующей за командой вызова подпрограммы) Достоинством такого метода является возможность разработки программ значительно большего объема небольшими функционально законченными частями.

Директива PROC процедулы MAIN имеет атрибут FAR, который связан с выполнением программы, а именно когда вы запрашиваете выполнение программы, загрузчик использует эту процедуру, как начальную точку для определения первой подлежащей исполнению команды.

Директива ENDP указывает на конец процедуры и содержит то же имя, что и предложение PROC, чтобы позволить ассемблеру соотнести конец процедуры и ее начало. Поскольку процедура должна полностью содержаться в одном сегменте, ENDP завершает процедуру перед тем, как ENDS определяет конец сегмента.

*4. Ваша программа состоит из главной процедуры и процедур-подпрограмм. Каким может быть взаимное расположение главной процедуры и подпрограмм?*

Язык программирования ассемблера поддерживает применение процедур двух типов – ближнего (near) и дальнего (far).

Процедуры ближнего типа должны находиться в том же сегменте, что и вызывающая программа. Дальний тип процедуры означает, что к ней можно обращаться из любого другого кодового сегмента.

Подпрограмму в теле программы стоит размещать либо в конце сегмента кода, после команд завершения программы, либо в самом начале сегмента кода, перед точкой входа в программу, чтобы процедура не выполнялась без её вызова. В больших программах подпрограммы часто размещают в отдельном кодовом сегменте.

*5. Как процессор использует стек при работе с любой процедурой?*

При вызове процедуры в стеке сохраняется адрес возврата в вызывающую программу:

- при вызове ближней процедуры – слово, содержащее смещение точки возврата относительно текущего кодового сегмента;

- при вызове дальней процедуры – слово, содержащее адрес сегмента, в котором расположена точка возврата, и слово, содержащее смещение точки возврата в этом сегменте

*6. С помощью какой команды вызывается процедура? Как меняется значение регистра SP после вызова процедуры? Приведите пример из вашей таблицы трассировки.*

Процедура вызыввается с помощью команды call. При вызове процедуры в стеке сохраняется адрес возврата в вызывающую программу. 

Пример из трассировки первой программы: до вызова процедуры out_string SP = FFFE, а после вызова SP = FFFC, после завершения процедры SP становится вновь равен FFFE. SP уменьшается ровно на 2 байта во время вызова процедуры из-за сохранения адреса возврата в стеке.

*7. После какой команды процедуры из стека извлекается адрес возврата?*

Адрес возврата извлекается из стека после завершение работы процедуры командой ret.

